{"version":3,"file":"xxhash-wasm.js","sources":["../src/index.js"],"sourcesContent":["// The .wasm is filled in by the build process, so the user doesn't need to load\n// xxhash.wasm by themselves because it's part of the bundle. Otherwise it\n// couldn't be distributed easily as the user would need to host xxhash.wasm\n// and then fetch it, to be able to use it.\n// eslint-disable-next-line no-undef\nconst wasmBytes = new Uint8Array(WASM_PRECOMPILED_BYTES);\n\nlet encoder;\n\nfunction writeBufferToMemory(buffer, memory, offset) {\n  if (memory.buffer.byteLength < buffer.byteLength + offset) {\n    const extraPages = Math.ceil(\n      (buffer.byteLength + offset - memory.buffer.byteLength) / (64 * 1024)\n    );\n    memory.grow(extraPages);\n  }\n  const u8memory = new Uint8Array(memory.buffer, offset);\n  u8memory.set(buffer);\n}\n\nasync function xxhash() {\n  const {\n    instance: {\n      exports: { mem, xxh32, xxh64 },\n    },\n  } = await WebAssembly.instantiate(wasmBytes);\n  function h32Raw(inputBuffer, seed = 0) {\n    writeBufferToMemory(inputBuffer, mem, 0);\n    // Logical shift right makes it an u32, otherwise it's interpreted as\n    // an i32.\n    return xxh32(0, inputBuffer.byteLength, seed) >>> 0;\n  }\n\n  function h32(str, seed = 0) {\n    if (!encoder) encoder = new TextEncoder();\n    const strBuffer = encoder.encode(str);\n    return h32Raw(strBuffer, seed).toString(16);\n  }\n\n  function h64RawToDataView(inputBuffer, seedHigh = 0, seedLow = 0) {\n    writeBufferToMemory(inputBuffer, mem, 8);\n    // The first word (64-bit) is used to communicate an u64 between\n    // JavaScript and WebAssembly. First the seed will be set from\n    // JavaScript and afterwards the result will be set from WebAssembly.\n    const dataView = new DataView(mem.buffer);\n    dataView.setUint32(0, seedHigh, true);\n    dataView.setUint32(4, seedLow, true);\n    xxh64(0, inputBuffer.byteLength);\n    return dataView;\n  }\n\n  function h64Raw(inputBuffer, seedHigh = 0, seedLow = 0) {\n    return new Uint8Array(\n      h64RawToDataView(inputBuffer, seedHigh, seedLow).buffer,\n      0,\n      8\n    );\n  }\n\n  function h64(str, seedHigh = 0, seedLow = 0) {\n    if (!encoder) encoder = new TextEncoder();\n    const strBuffer = encoder.encode(str);\n    const dataView = h64RawToDataView(strBuffer, seedHigh, seedLow);\n    const h64str =\n      dataView.getUint32(0, true).toString(16) +\n      dataView.getUint32(4, true).toString(16);\n    return h64str;\n  }\n\n  return {\n    h32,\n    h32Raw,\n    h64,\n    h64Raw,\n  };\n}\n\nexport default xxhash;\n"],"names":["wasmBytes","Uint8Array","encoder","writeBufferToMemory","buffer","memory","offset","byteLength","extraPages","Math","ceil","grow","set","async","instance","exports","mem","xxh32","xxh64","WebAssembly","instantiate","h32Raw","inputBuffer","seed","h64RawToDataView","seedHigh","seedLow","dataView","DataView","setUint32","h32","str","encode","toString","h64","getUint32","h64Raw"],"mappings":"aAKA,MAAMA,EAAY,IAAIC,WAAW,w9HAEjC,IAAIC,EAEJ,SAASC,EAAoBC,EAAQC,EAAQC,MACvCD,EAAOD,OAAOG,WAAaH,EAAOG,WAAaD,EAAQ,OACnDE,EAAaC,KAAKC,MACrBN,EAAOG,WAAaD,EAASD,EAAOD,OAAOG,mBAE9CF,EAAOM,KAAKH,GAEG,IAAIP,WAAWI,EAAOD,OAAQE,GACtCM,IAAIR,kBAGfS,uBAEIC,UACEC,SAASC,IAAEA,EAAFC,MAAOA,EAAPC,MAAcA,WAEjBC,YAAYC,YAAYpB,YACzBqB,EAAOC,EAAaC,EAAO,UAClCpB,EAAoBmB,EAAaN,EAAK,GAG/BC,EAAM,EAAGK,EAAYf,WAAYgB,KAAU,WAS3CC,EAAiBF,EAAaG,EAAW,EAAGC,EAAU,GAC7DvB,EAAoBmB,EAAaN,EAAK,SAIhCW,EAAW,IAAIC,SAASZ,EAAIZ,eAClCuB,EAASE,UAAU,EAAGJ,GAAU,GAChCE,EAASE,UAAU,EAAGH,GAAS,GAC/BR,EAAM,EAAGI,EAAYf,YACdoB,QAqBF,CACLG,aArCWC,EAAKR,EAAO,UAClBrB,IAASA,EAAU,oBAAA,cAEjBmB,EADWnB,EAAQ8B,OAAOD,GACRR,GAAMU,SAAS,KAmCxCZ,OAAAA,EACAa,aAbWH,EAAKN,EAAW,EAAGC,EAAU,GACnCxB,IAASA,EAAU,oBAAA,oBAElByB,EAAWH,EADCtB,EAAQ8B,OAAOD,GACYN,EAAUC,UAErDC,EAASQ,UAAU,GAAG,GAAMF,SAAS,IACrCN,EAASQ,UAAU,GAAG,GAAMF,SAAS,KAQvCG,gBAtBcd,EAAaG,EAAW,EAAGC,EAAU,UAC5C,IAAIzB,WACTuB,EAAiBF,EAAaG,EAAUC,GAAStB,OACjD,EACA"}