{"version":3,"file":"xxhash-wasm.js","sources":["../src/index.js"],"sourcesContent":["// The .wasm is filled in by the build process, so the user doesn't need to load\n// xxhash.wasm by themselves because it's part of the bundle. Otherwise it\n// couldn't be distributed easily as the user would need to host xxhash.wasm\n// and then fetch it, to be able to use it.\n// eslint-disable-next-line no-undef\nconst wasmBytes = new Uint8Array(WASM_PRECOMPILED_BYTES);\n\nlet encoder;\n\nfunction writeBufferToMemory(buffer, memory, offset) {\n  if (memory.buffer.byteLength < buffer.byteLength + offset) {\n    const extraPages = Math.ceil(\n      (buffer.byteLength + offset - memory.buffer.byteLength) / (64 * 1024)\n    );\n    memory.grow(extraPages);\n  }\n  const u8memory = new Uint8Array(memory.buffer, offset);\n  u8memory.set(buffer);\n}\n\nasync function xxhash() {\n  const {\n    instance: {\n      exports: { mem, xxh32, xxh64 },\n    },\n  } = await WebAssembly.instantiate(wasmBytes);\n  function h32Raw(inputBuffer, seed = 0) {\n    writeBufferToMemory(inputBuffer, mem, 0);\n    // Logical shift right makes it an u32, otherwise it's interpreted as\n    // an i32.\n    return xxh32(0, inputBuffer.byteLength, seed) >>> 0;\n  }\n\n  function h32(str, seed = 0) {\n    if (!encoder) encoder = new TextEncoder();\n    const strBuffer = encoder.encode(str);\n    return h32Raw(strBuffer, seed).toString(16);\n  }\n\n  function h64RawToDataView(inputBuffer, seedHigh = 0, seedLow = 0) {\n    writeBufferToMemory(inputBuffer, mem, 8);\n    // The first word (64-bit) is used to communicate an u64 between\n    // JavaScript and WebAssembly. First the seed will be set from\n    // JavaScript and afterwards the result will be set from WebAssembly.\n    const dataView = new DataView(mem.buffer);\n    dataView.setUint32(0, seedHigh, true);\n    dataView.setUint32(4, seedLow, true);\n    xxh64(0, inputBuffer.byteLength);\n    return dataView;\n  }\n\n  function h64Raw(inputBuffer, seedHigh = 0, seedLow = 0) {\n    return new Uint8Array(\n      h64RawToDataView(inputBuffer, seedHigh, seedLow).buffer,\n      0,\n      8\n    );\n  }\n\n  function h64(str, seedHigh = 0, seedLow = 0) {\n    if (!encoder) encoder = new TextEncoder();\n    const strBuffer = encoder.encode(str);\n    const dataView = h64RawToDataView(strBuffer, seedHigh, seedLow);\n    const h64str =\n      dataView.getUint32(0, true).toString(16) +\n      dataView.getUint32(4, true).toString(16);\n    return h64str;\n  }\n\n  return {\n    h32,\n    h32Raw,\n    h64,\n    h64Raw,\n  };\n}\n\nexport default xxhash;\n"],"names":["wasmBytes","Uint8Array","encoder","writeBufferToMemory","buffer","memory","offset","byteLength","extraPages","Math","ceil","grow","set","async","instance","exports","mem","xxh32","xxh64","WebAssembly","instantiate","h32Raw","inputBuffer","seed","h64RawToDataView","seedHigh","seedLow","dataView","DataView","setUint32","h32","str","TextEncoder","strBuffer","encode","toString","h64","h64str","getUint32","h64Raw"],"mappings":"AAKA,MAAMA,EAAY,IAAIC,WAAW,w9HAEjC,IAAIC,EAEJ,SAASC,EAAoBC,EAAQC,EAAQC,MACvCD,EAAOD,OAAOG,WAAaH,EAAOG,WAAaD,EAAQ,OACnDE,EAAaC,KAAKC,MACrBN,EAAOG,WAAaD,EAASD,EAAOD,OAAOG,mBAE9CF,EAAOM,KAAKH,GAEG,IAAIP,WAAWI,EAAOD,OAAQE,GACtCM,IAAIR,kBAGfS,uBAEIC,UACEC,SAASC,IAAEA,EAAFC,MAAOA,EAAPC,MAAcA,WAEjBC,YAAYC,YAAYpB,YACzBqB,EAAOC,OAAaC,yDAAO,SAClCpB,EAAoBmB,EAAaN,EAAK,GAG/BC,EAAM,EAAGK,EAAYf,WAAYgB,KAAU,WAS3CC,EAAiBF,OAAaG,yDAAW,EAAGC,yDAAU,EAC7DvB,EAAoBmB,EAAaN,EAAK,SAIhCW,EAAW,IAAIC,SAASZ,EAAIZ,eAClCuB,EAASE,UAAU,EAAGJ,GAAU,GAChCE,EAASE,UAAU,EAAGH,GAAS,GAC/BR,EAAM,EAAGI,EAAYf,YACdoB,QAqBF,CACLG,aArCWC,OAAKR,yDAAO,EAClBrB,IAASA,EAAU,IAAI8B,mBACtBC,EAAY/B,EAAQgC,OAAOH,UAC1BV,EAAOY,EAAWV,GAAMY,SAAS,KAmCxCd,OAAAA,EACAe,aAbWL,OAAKN,yDAAW,EAAGC,yDAAU,EACnCxB,IAASA,EAAU,IAAI8B,mBACtBC,EAAY/B,EAAQgC,OAAOH,GAC3BJ,EAAWH,EAAiBS,EAAWR,EAAUC,GACjDW,EACJV,EAASW,UAAU,GAAG,GAAMH,SAAS,IACrCR,EAASW,UAAU,GAAG,GAAMH,SAAS,WAChCE,GAOPE,gBAtBcjB,OAAaG,yDAAW,EAAGC,yDAAU,SAC5C,IAAIzB,WACTuB,EAAiBF,EAAaG,EAAUC,GAAStB,OACjD,EACA"}