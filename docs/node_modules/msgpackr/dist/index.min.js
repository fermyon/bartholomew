(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e=e||self,t(e.msgpackr={}))})(this,function(e){'use strict';var t=Math.floor;function n(){try{if(!D.trusted&&!Y){let e=M.sharedLength||0;e<M.length&&(M.length=e)}let e=r();if(B&&(// bundled strings to skip past
P=B.postBundlePosition),P==E)M.restoreStructures&&s(),M=null,R=null,C&&(C=null);else if(P>E){// over read
let e=new Error("Unexpected end of MessagePack data");throw e.incomplete=!0,e}else if(!Y)throw new Error("Data read, but end of buffer not reached");// else more to read, but we are reading sequentially, so don't clear source yet
return e}catch(e){throw M.restoreStructures&&s(),m(),(e instanceof RangeError||e.message.startsWith("Unexpected end of buffer"))&&(e.incomplete=!0),e}}function s(){for(let e in M.restoreStructures)M[e]=M.restoreStructures[e];M.restoreStructures=null}function r(){let e=R[P++];if(160>e){if(!(128>e)){if(!(144>e)){e-=144;let t=Array(e);for(let n=0;n<e;n++)t[n]=r();return t}if(e-=128,D.mapsAsObjects){let t={};for(let n=0;n<e;n++)t[h()]=r();return t}else{let t=new Map;for(let n=0;n<e;n++)t.set(r(),r());return t}}else if(64>e)return e;else{let t=M[63&e]||D.getStructures&&o()[63&e];return t?(t.read||(t.read=i(t,63&e)),t.read()):e}}else if(192>e){// fixstr
let t=e-160;if(j>=P)return _.slice(P-F,(P+=t)-F);if(0==j&&140>E){// for small blocks, avoiding the overhead of the extract call is helpful
let e=16>t?g(t):c(t);if(null!=e)return e}return H(t)}else{let t;switch(e){case 192:return null;case 193:return B?(t=r(),0<t?B[1].slice(B.position1,B.position1+=t):B[0].slice(B.position0,B.position0-=t)):W;// "never-used", return special object to denote that
case 194:return!1;case 195:return!0;case 196:// bin 8
return l(R[P++]);case 197:return t=T.getUint16(P),P+=2,l(t);case 198:return t=T.getUint32(P),P+=4,l(t);case 199:// ext 8
return f(R[P++]);case 200:return t=T.getUint16(P),P+=2,f(t);case 201:return t=T.getUint32(P),P+=4,f(t);case 202:if(t=T.getFloat32(P),2<D.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let e=re[(127&R[P])<<1|R[P+1]>>7];return P+=4,(e*t+(0<t?.5:-.5)>>0)/e}return P+=4,t;case 203:return t=T.getFloat64(P),P+=8,t;// uint handlers
case 204:return R[P++];case 205:return t=T.getUint16(P),P+=2,t;case 206:return t=T.getUint32(P),P+=4,t;case 207:return D.int64AsNumber?(t=4294967296*T.getUint32(P),t+=T.getUint32(P+4)):t=T.getBigUint64(P),P+=8,t;// int handlers
case 208:return T.getInt8(P++);case 209:return t=T.getInt16(P),P+=2,t;case 210:return t=T.getInt32(P),P+=4,t;case 211:return D.int64AsNumber?(t=4294967296*T.getInt32(P),t+=T.getUint32(P+4)):t=T.getBigInt64(P),P+=8,t;case 212:if(t=R[P++],114==t)return ee(63&R[P++]);else{let e=v[t];if(e)return e.read?(P++,e.read(r())):e.noBuffer?(P++,e()):e(R.subarray(P,++P));throw new Error("Unknown extension "+t)}case 213:return t=R[P],114==t?(P++,ee(63&R[P++],R[P++])):f(2);case 214:// fixext 4
return f(4);case 215:// fixext 8
return f(8);case 216:// fixext 16
return f(16);case 217:return t=R[P++],j>=P?_.slice(P-F,(P+=t)-F):J(t);case 218:return t=T.getUint16(P),P+=2,j>=P?_.slice(P-F,(P+=t)-F):K(t);case 219:return t=T.getUint32(P),P+=4,j>=P?_.slice(P-F,(P+=t)-F):Q(t);case 220:return t=T.getUint16(P),P+=2,u(t);case 221:return t=T.getUint32(P),P+=4,u(t);case 222:return t=T.getUint16(P),P+=2,d(t);case 223:return t=T.getUint32(P),P+=4,d(t);default:// negative int
if(224<=e)return e-256;if(void 0===e){let e=new Error("Unexpected end of MessagePack data");throw e.incomplete=!0,e}throw new Error("Unknown MessagePack token "+e);}}}function i(e,t){function n(){// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
if(n.count++>z){let n=e.read=new Function("r","return function(){return {"+e.map(e=>q.test(e)?e+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"}}")(r);return 0===e.highByte&&(e.read=G(t,e.read)),n();// second byte is already read, if there is one so immediately read object
}let s={};for(let t,n=0,i=e.length;n<i;n++)t=e[n],s[t]=r();return s}return n.count=0,0===e.highByte?G(t,n):n}function o(){let e=y(()=>(R=null,D.getStructures()));return M=D._mergeStructures(e,M)}function a(e){let t;if(16>e&&(t=g(e)))return t;if(64<e&&x)return x.decode(R.subarray(P,P+=e));const n=P+e,s=[];for(t="";P<n;){const e=R[P++];if(0==(128&e))s.push(e);else if(192==(224&e)){// 2 bytes
const t=63&R[P++];s.push((31&e)<<6|t)}else if(224==(240&e)){// 3 bytes
const t=63&R[P++],n=63&R[P++];s.push((31&e)<<12|t<<6|n)}else if(240==(248&e)){// 4 bytes
const t=63&R[P++],n=63&R[P++],r=63&R[P++];let i=(7&e)<<18|t<<12|n<<6|r;65535<i&&(i-=65536,s.push(55296|1023&i>>>10),i=56320|1023&i),s.push(i)}else s.push(e);4096<=s.length&&(t+=X.apply(String,s),s.length=0)}return 0<s.length&&(t+=X.apply(String,s)),t}function u(e){let t=Array(e);for(let n=0;n<e;n++)t[n]=r();return t}function d(e){if(D.mapsAsObjects){let t={};for(let n=0;n<e;n++)t[h()]=r();return t}else{let t=new Map;for(let n=0;n<e;n++)t.set(r(),r());return t}}function c(e){let t=P,n=Array(e);for(let s=0;s<e;s++){const e=R[P++];if(0<(128&e))return void(P=t);n[s]=e}return X.apply(String,n)}function g(t){if(4>t){if(!(2>t)){let e=R[P++],n=R[P++];if(0<(128&e)||0<(128&n))return void(P-=2);if(3>t)return X(e,n);let s=R[P++];return 0<(128&s)?void(P-=3):X(e,n,s)}if(0===t)return"";else{let e=R[P++];return 1<(128&e)?void(P-=1):X(e)}}else{let s=R[P++],r=R[P++],a=R[P++],u=R[P++];if(0<(128&s)||0<(128&r)||0<(128&a)||0<(128&u))return void(P-=4);if(6>t){if(4===t)return X(s,r,a,u);else{let t=R[P++];return 0<(128&t)?void(P-=5):X(s,r,a,u,t)}}else if(8>t){let n=R[P++],e=R[P++];if(0<(128&n)||0<(128&e))return void(P-=6);if(7>t)return X(s,r,a,u,n,e);let i=R[P++];return 0<(128&i)?void(P-=7):X(s,r,a,u,n,e,i)}else{let d=R[P++],e=R[P++],c=R[P++],g=R[P++];if(0<(128&d)||0<(128&e)||0<(128&c)||0<(128&g))return void(P-=8);if(10>t){if(8===t)return X(s,r,a,u,d,e,c,g);else{let t=R[P++];return 0<(128&t)?void(P-=9):X(s,r,a,u,d,e,c,g,t)}}else if(12>t){let n=R[P++],i=R[P++];if(0<(128&n)||0<(128&i))return void(P-=10);if(11>t)return X(s,r,a,u,d,e,c,g,n,i);let o=R[P++];return 0<(128&o)?void(P-=11):X(s,r,a,u,d,e,c,g,n,i,o)}else{let p=R[P++],i=R[P++],f=R[P++],h=R[P++];if(0<(128&p)||0<(128&i)||0<(128&f)||0<(128&h))return void(P-=12);if(!(14>t)){let l=R[P++],y=R[P++];if(0<(128&l)||0<(128&y))return void(P-=14);if(15>t)return X(s,r,a,u,d,e,c,g,p,i,f,h,l,y);let n=R[P++];return 0<(128&n)?void(P-=15):X(s,r,a,u,d,e,c,g,p,i,f,h,l,y,n)}if(12===t)return X(s,r,a,u,d,e,c,g,p,i,f,h);else{let t=R[P++];return 0<(128&t)?void(P-=13):X(s,r,a,u,d,e,c,g,p,i,f,h,t)}}}}}function p(){let e,t=R[P++];if(192>t)// fixstr
e=t-160;else switch(t){case 217:e=R[P++];break;case 218:e=T.getUint16(P),P+=2;break;case 219:e=T.getUint32(P),P+=4;break;default:throw new Error("Expected string");}return a(e)}function l(e){return D.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(R,P,P+=e):R.subarray(P,P+=e)}function f(e){let t=R[P++];if(v[t])return v[t](R.subarray(P,P+=e));throw new Error("Unknown extension type "+t)}function h(){let e=R[P++];if(160<=e&&192>e){if(e-=160,j>=P)// if it has been extracted, must use it (and faster anyway)
return _.slice(P-F,(P+=e)-F);if(!(0==j&&180>E))return H(e)}else return P--,r();let t,n=4095&(e<<5^(1<e?T.getUint16(P):0<e?R[P]:0)),s=Z[n],o=P,a=P+e-3,u=0;if(s&&s.bytes==e){for(;o<a;){if(t=T.getUint32(o),t!=s[u++]){o=1879048192;break}o+=4}for(a+=3;o<a;)if(t=R[o++],t!=s[u++]){o=1879048192;break}if(o===a)return P=o,s.string;a-=3,o=P}for(s=[],Z[n]=s,s.bytes=e;o<a;)t=T.getUint32(o),s.push(t),o+=4;for(a+=3;o<a;)t=R[o++],s.push(t);// for small blocks, avoiding the overhead of the extract call is helpful
let d=16>e?g(e):c(e);return null==d?s.string=H(e):s.string=d}// the registration of the record definition extension (as "r")
// notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>
function y(e){let t=E,n=P,s=F,r=j,i=_,o=C,a=B,u=new Uint8Array(R.slice(0,E)),d=M,c=M.slice(0,M.length),g=D,p=Y,l=e();return E=t,P=n,F=s,j=r,_=i,C=o,B=a,R=u,Y=p,M=d,M.splice(0,M.length,...c),D=g,T=new DataView(R.buffer,R.byteOffset,R.byteLength),l}function m(){R=null,C=null,M=null}function b(e){v[e.type]=e.unpack?e.unpack:e}function k(e,t,n){let s=e.byteLength;if(256>s+1){var{target:r,position:i}=n(4+s);r[i++]=199,r[i++]=s+1}else if(65536>s+1){var{target:r,position:i}=n(5+s);r[i++]=200,r[i++]=s+1>>8,r[i++]=255&s+1}else{var{target:r,position:i,targetView:o}=n(7+s);// plus one for the type byte
r[i++]=201,o.setUint32(i,s+1),i+=4}// "t" for typed array
r[i++]=116,r[i++]=t,r.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength),i)}function U(e,t){let n=e.byteLength;var s,r;if(256>n){var{target:s,position:r}=t(n+2);s[r++]=196,s[r++]=n}else if(65536>n){var{target:s,position:r}=t(n+3);s[r++]=197,s[r++]=n>>8,s[r++]=255&n}else{var{target:s,position:r,targetView:i}=t(n+5);s[r++]=198,i.setUint32(r,n),r+=4}s.set(e,r)}function I(e,t,n,s){let r=e.length;return 1===r?t[n++]=212:2===r?t[n++]=213:4===r?t[n++]=214:8===r?t[n++]=215:16===r?t[n++]=216:256>r?(t[n++]=199,t[n++]=r):65536>r?(t[n++]=200,t[n++]=r>>8,t[n++]=255&r):(t[n++]=201,t[n++]=r>>24,t[n++]=255&r>>16,t[n++]=255&r>>8,t[n++]=255&r),t[n++]=s,t.set(e,n),n+=r,n}function S(e,t){// insert the ids that need to be referenced for structured clones
let n,s=6*t.length,r=e.length-s;for(t.sort((e,t)=>e.offset>t.offset?1:-1);n=t.pop();){let t=n.offset,i=n.id;e.copyWithin(t+s,t,r),s-=6;let o=t+s;// 'i'
e[o++]=214,e[o++]=105,e[o++]=i>>24,e[o++]=255&i>>16,e[o++]=255&i>>8,e[o++]=255&i,r=t}return e}function O(e,t){Ie.setUint32(Ae.position+e,Oe-Ae.position-e);let n=Ae;Ae=null,t(n[0]),t(n[1])}function A(e){if(e.Class){if(!e.pack&&!e.write)throw new Error("Extension has no pack or write function");if(e.pack&&!e.type)throw new Error("Extension has no type (numeric code to identify the extension)");fe.unshift(e.Class),le.unshift(e)}b(e)}function*w(e,t){const n=new Le(t);for(const s of e)yield n.pack(s)}async function*L(e,t){const n=new Le(t);for await(const s of e)yield n.pack(s)}/**
	 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
	 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
	 * @param {object} [options] - unpackr options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
	 */var x;try{x=new TextDecoder}catch(e){}var R,E,M,_,B,C,T,P=0,D={},F=0,j=0,v=[],N={useRecords:!1,mapsAsObjects:!0};class V{}const W=new V;W.name="MessagePack 0xC1";var Y=!1,z=2;try{new Function("")}catch(e){// if eval variants are not supported, do not create inline object readers ever
z=1/0}class ${constructor(e){e&&(!1===e.useRecords&&e.mapsAsObjects===void 0&&(e.mapsAsObjects=!0),e.structures?e.structures.sharedLength=e.structures.length:e.getStructures&&((e.structures=[]).uninitialized=!0,e.structures.sharedLength=0)),Object.assign(this,e)}unpack(e,t){if(R)// re-entrant execution, save the state and restore it after we do this unpack
return y(()=>(m(),this?this.unpack(e,t):$.prototype.unpack.call(N,e,t)));E=-1<t?t:e.length,P=0,j=0,_=null,B=null,R=e;// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
// technique for getting data from a database where it can be copied into an existing buffer instead of creating
// new ones
try{T=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(t){if(R=null,e instanceof Uint8Array)throw t;throw new Error("Source must be a Uint8Array or Buffer but was a "+(e&&"object"==typeof e?e.constructor.name:typeof e))}if(this instanceof $){if(D=this,this.structures)return M=this.structures,n();(!M||0<M.length)&&(M=[])}else D=N,(!M||0<M.length)&&(M=[]);return n()}unpackMultiple(e,t){let s,r=0;try{Y=!0;let i=e.length,o=this?this.unpack(e,i):ie.unpack(e,i);if(t){for(t(o);P<i;)if(r=P,!1===t(n()))return;}else{for(s=[o];P<i;)r=P,s.push(n());return s}}catch(e){throw e.lastPosition=r,e.values=s,e}finally{Y=!1,m()}}_mergeStructures(e,t){e=e||[];for(let n,s=0,r=e.length;s<r;s++)n=e[s],n&&(n.isShared=!0,32<=s&&(n.highByte=s-32>>5));for(let n in e.sharedLength=e.length,t||[])if(0<=n){let s=e[n],r=t[n];r&&(s&&((e.restoreStructures||(e.restoreStructures=[]))[n]=s),e[n]=r)}return this.structures=e}decode(e,t){return this.unpack(e,t)}}const q=/^[a-zA-Z_$][a-zA-Z\d_$]*$/,G=(e,t)=>function(){let n=R[P++];if(0===n)return t();let s=32>e?-(e+(n<<5)):e+(n<<5),r=M[s]||o()[s];if(!r)throw new Error("Record id is not defined for "+s);return r.read||(r.read=i(r,e)),r.read()};var H=a,J=a,K=a,Q=a;var X=String.fromCharCode,Z=Array(4096);const ee=(e,t)=>{var n=r();let s=e;void 0!==t&&(e=32>e?-((t<<5)+e):(t<<5)+e,n.highByte=t);let o=M[e];return o&&o.isShared&&((M.restoreStructures||(M.restoreStructures=[]))[e]=o),M[e]=n,n.read=i(n,s),n.read()};var te="object"==typeof self?self:global;v[0]=()=>{},v[0].noBuffer=!0,v[101]=()=>{let e=r();return(te[e[0]]||Error)(e[1])},v[105]=()=>{// id extension (for structured clones)
let e=T.getUint32(P-4);C||(C=new Map);let t,n=R[P];t=144<=n&&160>n||220==n||221==n?[]:{};let s={target:t};// a placeholder object
C.set(e,s);let i=r();// read the next value as the target object to id
return s.used?Object.assign(t,i):(s.target=i,i);// no cycle, can just use the returned read object
},v[112]=()=>{// pointer extension (for structured clones)
let e=T.getUint32(P-4),t=C.get(e);return t.used=!0,t.target},v[115]=()=>new Set(r());const ne=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(e=>e+"Array");v[116]=e=>{let t=e[0],n=ne[t];if(!n)throw new Error("Could not find typed array for code "+t);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new te[n](Uint8Array.prototype.slice.call(e,1).buffer)},v[120]=()=>{let e=r();return new RegExp(e[0],e[1])};const se=[];v[98]=e=>{let t=(e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3],n=P;return P+=t-e.length,B=se,B=[p(),p()],B.position0=0,B.position1=0,B.postBundlePosition=P,P=n,r()},v[255]=e=>4==e.length?new Date(1e3*(16777216*e[0]+(e[1]<<16)+(e[2]<<8)+e[3])):8==e.length?new Date(((e[0]<<22)+(e[1]<<14)+(e[2]<<6)+(e[3]>>2))/1e6+1e3*(4294967296*(3&e[3])+16777216*e[4]+(e[5]<<16)+(e[6]<<8)+e[7])):12==e.length?new Date(((e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3])/1e6+1e3*((128&e[4]?-281474976710656:0)+1099511627776*e[6]+4294967296*e[7]+16777216*e[8]+(e[9]<<16)+(e[10]<<8)+e[11])):new Date("invalid");const re=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let n=0;256>n;n++)re[n]=+("1e"+t(45.15-.30103*n));var ie=new $({useRecords:!1});const oe=ie.unpack,ae=ie.unpackMultiple,ue=ie.unpack,de={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let ce,ge=new Float32Array(1),pe=new Uint8Array(ge.buffer,0,4);try{ce=new TextEncoder}catch(e){}let le,fe;const he="undefined"!=typeof Buffer,ye=he?Buffer.allocUnsafeSlow:Uint8Array,me=he?Buffer:Uint8Array,be=he?4294967296:2144337920;let ke,Ue,Ie,Se,Oe=0,Ae=null;const we=Symbol("record-id");class Le extends ${constructor(e){super(e),this.offset=0;let t,n,s,r,i=0,o=me.prototype.utf8Write?function(e,t,n){return ke.utf8Write(e,t,n)}:!!(ce&&ce.encodeInto)&&function(e,t){return ce.encodeInto(e,ke.subarray(t)).written},a=this;e||(e={});let u=e&&e.sequential,d=e.structures||e.saveStructures,c=e.maxSharedStructures;if(null==c&&(c=d?32:0),8160<c)throw new Error("Maximum maxSharedStructure is 8160");e.structuredClone&&null==e.moreTypes&&(e.moreTypes=!0);let g=e.maxOwnStructures;null==g&&(g=d?32:64),this.structures||!1==e.useRecords||(this.structures=[]);// two byte record ids for shared structures
let p=32<c||64<g+c,l=c+64,f=c+g+64;if(8256<f)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let h=[],y=0,m=0;this.pack=this.encode=function(e,o){if(ke||(ke=new ye(8192),Ie=new DataView(ke.buffer,0,8192),Oe=0),Se=ke.length-10,2048>Se-Oe?(ke=new ye(ke.length),Ie=new DataView(ke.buffer,0,ke.length),Se=ke.length-10,Oe=0):Oe=2147483640&Oe+7,t=Oe,r=a.structuredClone?new Map:null,a.bundleStrings&&"string"!=typeof e?(Ae=[],Ae.size=1/0):Ae=null,s=a.structures,s){s.uninitialized&&(s=a._mergeStructures(a.getStructures()));let e=s.sharedLength||0;if(e>c)//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids
throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+s.sharedLength);if(!s.transitions){s.transitions=Object.create(null);for(let t,n=0;n<e;n++){if(t=s[n],!t)continue;let e,r=s.transitions;for(let n,s=0,i=t.length;s<i;s++)n=t[s],e=r[n],e||(e=r[n]=Object.create(null)),r=e;r[we]=n+64}i=e}u||(s.nextId=e+64)}n&&(n=!1);try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(b(e),Ae&&O(t,b),a.offset=Oe,r&&r.idsToInsert){Oe+=6*r.idsToInsert.length,Oe>Se&&U(Oe),a.offset=Oe;let e=S(ke.subarray(t,Oe),r.idsToInsert);return r=null,e}return o&Te?(ke.start=t,ke.end=Oe,ke):ke.subarray(t,Oe);// position can change if we call pack again in saveStructures, so we get the buffer now
}finally{if(s){10>m&&m++;let r=s.sharedLength||c;if(s.length>r&&(s.length=r),1e4<y)s.transitions=null,m=0,y=0,0<h.length&&(h=[]);else if(0<h.length&&!u){for(let e=0,t=h.length;e<t;e++)h[e][we]=0;h=[]}if(n&&a.saveStructures){// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
let n=ke.subarray(t,Oe);return!1===a.saveStructures(s,i)?(a._mergeStructures(a.getStructures()),a.pack(e)):(i=r,n)}}o&Pe&&(Oe=t)}};const b=e=>{Oe>Se&&(ke=U(Oe));var n,s=typeof e;if("string"==s){let s=e.length;if(Ae&&4<=s&&4096>s){if((Ae.size+=s)>61440){let e,n=(Ae[0]?3*Ae[0].length+Ae[1].length:0)+10;Oe+n>Se&&(ke=U(Oe+n)),Ae.position?(ke[Oe]=200,Oe+=3,ke[Oe++]=98,e=Oe-t,Oe+=4,O(t,b),Ie.setUint16(e+t-3,Oe-t-e)):(ke[Oe++]=214,ke[Oe++]=98,e=Oe-t,Oe+=4),Ae=["",""],Ae.size=0,Ae.position=e}let n=/[\u0080-\uFFFF]/.test(e);return Ae[n?0:1]+=e,ke[Oe++]=193,void b(n?-s:s)}let r=32>s?1:256>s?2:65536>s?3:5;// first we estimate the header size, so we can write to the correct location
let i=3*s;if(Oe+i>Se&&(ke=U(Oe+i)),64>s||!o){let t,i,o,a=Oe+r;for(t=0;t<s;t++)i=e.charCodeAt(t),128>i?ke[a++]=i:2048>i?(ke[a++]=192|i>>6,ke[a++]=128|63&i):55296==(64512&i)&&56320==(64512&(o=e.charCodeAt(t+1)))?(i=65536+((1023&i)<<10)+(1023&o),t++,ke[a++]=240|i>>18,ke[a++]=128|63&i>>12,ke[a++]=128|63&i>>6,ke[a++]=128|63&i):(ke[a++]=224|i>>12,ke[a++]=128|63&i>>6,ke[a++]=128|63&i);n=a-Oe-r}else n=o(e,Oe+r,i);32>n?ke[Oe++]=160|n:256>n?(2>r&&ke.copyWithin(Oe+2,Oe+1,Oe+1+n),ke[Oe++]=217,ke[Oe++]=n):65536>n?(3>r&&ke.copyWithin(Oe+3,Oe+2,Oe+2+n),ke[Oe++]=218,ke[Oe++]=n>>8,ke[Oe++]=255&n):(5>r&&ke.copyWithin(Oe+5,Oe+3,Oe+3+n),ke[Oe++]=219,Ie.setUint32(Oe,n),Oe+=4),Oe+=n}else if("number"===s){if(e>>>0===e)64>e?ke[Oe++]=e:256>e?(ke[Oe++]=204,ke[Oe++]=e):65536>e?(ke[Oe++]=205,ke[Oe++]=e>>8,ke[Oe++]=255&e):(ke[Oe++]=206,Ie.setUint32(Oe,e),Oe+=4);else if(e>>0===e)-32<=e?ke[Oe++]=256+e:-128<=e?(ke[Oe++]=208,ke[Oe++]=e+256):-32768<=e?(ke[Oe++]=209,Ie.setInt16(Oe,e),Oe+=2):(ke[Oe++]=210,Ie.setInt32(Oe,e),Oe+=4);else{let t;if(0<(t=this.useFloat32)&&4294967296>e&&-2147483648<=e){ke[Oe++]=202,Ie.setFloat32(Oe,e);let n;if(4>t||// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(n=e*re[(127&ke[Oe])<<1|ke[Oe+1]>>7])>>0===n)return void(Oe+=4);// move back into position for writing a double
Oe--}ke[Oe++]=203,Ie.setFloat64(Oe,e),Oe+=8}}else if("object"===s){if(!e)ke[Oe++]=192;else{if(r){let n=r.get(e);if(n){if(!n.id){let e=r.idsToInsert||(r.idsToInsert=[]);n.id=e.push(n)}return ke[Oe++]=214,ke[Oe++]=112,Ie.setUint32(Oe,n.id),void(Oe+=4)}r.set(e,{offset:Oe-t})}let s=e.constructor;if(s===Object)k(e,!0);else if(s===Array){n=e.length,16>n?ke[Oe++]=144|n:65536>n?(ke[Oe++]=220,ke[Oe++]=n>>8,ke[Oe++]=255&n):(ke[Oe++]=221,Ie.setUint32(Oe,n),Oe+=4);for(let t=0;t<n;t++)b(e[t])}else if(s===Map){n=e.size,16>n?ke[Oe++]=128|n:65536>n?(ke[Oe++]=222,ke[Oe++]=n>>8,ke[Oe++]=255&n):(ke[Oe++]=223,Ie.setUint32(Oe,n),Oe+=4);for(let[t,n]of e)b(t),b(n)}else{for(let t,n=0,s=le.length;n<s;n++)if(t=fe[n],e instanceof t){let t=le[n];if(t.write)return t.type&&(ke[Oe++]=212,ke[Oe++]=t.type,ke[Oe++]=0),void b(t.write.call(this,e));let s=ke,r=Ie,i=Oe;ke=null;let o;try{o=t.pack.call(this,e,e=>(ke=s,s=null,Oe+=e,Oe>Se&&U(Oe),{target:ke,targetView:Ie,position:Oe-e}),b)}finally{s&&(ke=s,Ie=r,Oe=i,Se=ke.length-10)}return void(o&&(o.length+Oe>Se&&U(o.length+Oe),Oe=I(o,ke,Oe,t.type)))}// no extension found, write as object
k(e,!e.hasOwnProperty)}}}else if("boolean"===s)ke[Oe++]=e?195:194;else if("bigint"===s){if(e<BigInt(1)<<BigInt(63)&&e>=-(BigInt(1)<<BigInt(63)))ke[Oe++]=211,Ie.setBigInt64(Oe,e);else if(e<BigInt(1)<<BigInt(64)&&0<e)ke[Oe++]=207,Ie.setBigUint64(Oe,e);else// overflow
if(this.largeBigIntToFloat)ke[Oe++]=203,Ie.setFloat64(Oe,+e);else throw new RangeError(e+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");Oe+=8}else if("undefined"===s)this.encodeUndefinedAsNil?ke[Oe++]=192:(ke[Oe++]=212,ke[Oe++]=0,ke[Oe++]=0);else if("function"===s)b(this.writeFunction&&this.writeFunction());else throw new Error("Unknown type: "+s)},k=!1===this.useRecords?this.variableMapSize?e=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let t=Object.keys(e),n=t.length;16>n?ke[Oe++]=128|n:65536>n?(ke[Oe++]=222,ke[Oe++]=n>>8,ke[Oe++]=255&n):(ke[Oe++]=223,Ie.setUint32(Oe,n),Oe+=4);let s;for(let r=0;r<n;r++)b(s=t[r]),b(e[s])}:(e,n)=>{ke[Oe++]=222;// always using map 16, so we can preallocate and set the length afterwards
let s=Oe-t;Oe+=2;let r=0;for(let t in e)(n||e.hasOwnProperty(t))&&(b(t),b(e[t]),r++);ke[s++ +t]=r>>8,ke[s+t]=255&r}:e.progressiveRecords&&!p?// this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
(e,n)=>{let r,i,o=s.transitions||(s.transitions=Object.create(null)),a=Oe++-t;for(let u in e)if(n||e.hasOwnProperty(u)){if(r=o[u],r)o=r;else{// record doesn't exist, create full new record and insert it
let n=Object.keys(e),d=o;o=s.transitions;let c=0;for(let e,t=0,s=n.length;t<s;t++)e=n[t],r=o[e],r||(r=o[e]=Object.create(null),c++),o=r;a+t+1==Oe?(Oe--,A(o,n,c)):// otherwise we need to insert the record, moving existing data after the record
w(o,n,a,c),i=!0,o=d[u]}b(e[u])}if(!i){let n=o[we];n?ke[a+t]=n:w(o,Object.keys(e),a,0)}}:(e,t)=>{let n,r=s.transitions||(s.transitions=Object.create(null)),i=0;for(let s in e)(t||e.hasOwnProperty(s))&&(n=r[s],n||(n=r[s]=Object.create(null),i++),r=n);let o=r[we];// now write the values
for(let n in o?96<=o&&p?(ke[Oe++]=(31&(o-=96))+96,ke[Oe++]=o>>5):ke[Oe++]=o:A(r,r.__keys__||Object.keys(e),i),e)(t||e.hasOwnProperty(n))&&b(e[n])},U=e=>{var n=Math.min,s=Math.round,r=Math.max;let i;if(16777216<e){// special handling for really large buffers
if(e-t>be)throw new Error("Packed buffer would be larger than maximum buffer size");i=n(be,4096*s(r((e-t)*(67108864<e?1.25:2),4194304)/4096))}else// faster handling for smaller buffers
i=(r(e-t<<2,ke.length-1)>>12)+1<<12;let o=new ye(i);return Ie=new DataView(o.buffer,0,i),ke.copy?ke.copy(o,0,t,e):o.set(ke.slice(t,e)),Oe-=t,t=0,Se=o.length-10,ke=o},A=(e,t,r)=>{let i=s.nextId;i||(i=64),i<l&&this.shouldShareStructure&&!this.shouldShareStructure(t)?(i=s.nextOwnId,!(i<f)&&(i=l),s.nextOwnId=i+1):(i>=f&&(// cycle back around
i=l),s.nextId=i+1);let o=t.highByte=96<=i&&p?i-96>>5:-1;e[we]=i,e.__keys__=t,s[i-64]=t,i<l?(t.isShared=!0,s.sharedLength=i-63,n=!0,0<=o?(ke[Oe++]=(31&i)+96,ke[Oe++]=o):ke[Oe++]=i):(0<=o?(ke[Oe++]=213,ke[Oe++]=114,ke[Oe++]=(31&i)+96,ke[Oe++]=o):(ke[Oe++]=212,ke[Oe++]=114,ke[Oe++]=i),r&&(y+=m*r),h.length>=g&&(h.shift()[we]=0),h.push(e),b(t))},w=(e,n,s,r)=>{let i=ke,o=Oe,a=Se,u=t;ke=Ue,Oe=0,t=0,ke||(Ue=ke=new ye(8192)),Se=ke.length-10,A(e,n,r),Ue=ke;let d=Oe;if(ke=i,Oe=o,Se=a,t=u,1<d){let e=Oe+d-1;e>Se&&U(e);let n=s+t;ke.copyWithin(n+d,n+1,Oe),ke.set(Ue.slice(0,d),n),Oe=e}else ke[s+t]=Ue[0]}}useBuffer(e){// this means we are finished using our own buffer and we can write over it safely
ke=e,Ie=new DataView(ke.buffer,ke.byteOffset,ke.byteLength),Oe=0}clearSharedData(){this.structures&&(this.structures=[])}}fe=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor/*TypedArray*/,V],le=[{pack(e,n,s){let r=e.getTime()/1e3;if((this.useTimestamp32||0===e.getMilliseconds())&&0<=r&&4294967296>r){// Timestamp 32
let{target:e,targetView:t,position:s}=n(6);e[s++]=214,e[s++]=255,t.setUint32(s,r)}else if(0<r&&17179869184>r){// Timestamp 64
let{target:t,targetView:s,position:i}=n(10);t[i++]=215,t[i++]=255,s.setUint32(i,4e6*e.getMilliseconds()+(r/1e3/4294967296>>0)),s.setUint32(i+4,r)}else if(isNaN(r)){if(this.onInvalidDate)return n(0),s(this.onInvalidDate());// Intentionally invalid timestamp
let{target:e,targetView:t,position:r}=n(3);e[r++]=212,e[r++]=255,e[r++]=255}else{// Timestamp 96
let{target:s,targetView:i,position:o}=n(15);s[o++]=199,s[o++]=12,s[o++]=255,i.setUint32(o,1e6*e.getMilliseconds()),i.setBigInt64(o+4,BigInt(t(r)))}}},{pack(e,t,n){let s=Array.from(e),{target:r,position:i}=t(this.moreTypes?3:0);this.moreTypes&&(r[i++]=212,r[i++]=115,r[i++]=0),n(s)}},{pack(e,t,n){let{target:s,position:r}=t(this.moreTypes?3:0);this.moreTypes&&(s[r++]=212,s[r++]=101,s[r++]=0),n([e.name,e.message])}},{pack(e,t,n){let{target:s,position:r}=t(this.moreTypes?3:0);this.moreTypes&&(s[r++]=212,s[r++]=120,s[r++]=0),n([e.source,e.flags])}},{pack(e,t){this.moreTypes?k(e,16,t):U(he?Buffer.from(e):new Uint8Array(e),t)}},{pack(e,t){let n=e.constructor;n!==me&&this.moreTypes?k(e,ne.indexOf(n.name),t):U(e,t)}},{pack(e,t){// specific 0xC1 object
let{target:n,position:s}=t(1);n[s]=193}}];let xe=new Le({useRecords:!1});const Re=xe.pack,Ee=xe.pack,{NEVER:Me,ALWAYS:_e,DECIMAL_ROUND:Be,DECIMAL_FIT:Ce}=de,Te=512,Pe=1024;e.ALWAYS=_e,e.C1=W,e.DECIMAL_FIT=Ce,e.DECIMAL_ROUND=Be,e.Decoder=$,e.Encoder=Le,e.FLOAT32_OPTIONS=de,e.NEVER=Me,e.Packr=Le,e.REUSE_BUFFER_MODE=Te,e.Unpackr=$,e.addExtension=A,e.clearSource=m,e.decode=ue,e.decodeIter=function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const n=new $(t);let s;const r=e=>{let t;// if there's incomplete data from previous chunk, concatinate and try again
s&&(e=Buffer.concat([s,e]),s=void 0);try{t=n.unpackMultiple(e)}catch(n){if(n.incomplete)s=e.slice(n.lastPosition),t=n.values;else throw n}return t};if("function"==typeof e[Symbol.iterator])return function*(){for(const t of e)yield*r(t)}();return"function"==typeof e[Symbol.asyncIterator]?async function*(){for await(const t of e)yield*r(t)}():void 0},e.encode=Ee,e.encodeIter=/**
	 * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer
	 * If the argument is only Async Iterable, the return value will be an Async Iterable.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
	 * @param {options} [options] - msgpackr pack options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
	 */function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof e[Symbol.iterator])return w(e,t);if("function"==typeof e.then||"function"==typeof e[Symbol.asyncIterator])return L(e,t);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},e.isNativeAccelerationEnabled=!1,e.mapsAsObjects=!0,e.pack=Re,e.roundFloat32=function(e){ge[0]=e;let t=re[(127&pe[3])<<1|pe[2]>>7];return(t*e+(0<e?.5:-.5)>>0)/t},e.unpack=oe,e.unpackMultiple=ae,e.useRecords=!1,Object.defineProperty(e,"__esModule",{value:!0})});
